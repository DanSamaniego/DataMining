---
title: "2 Hands On: Data Quality and Pre-Processing"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

## 1. Assessing Data Quality
Load the following packages: dplyr, na.tools, tidyimpute (version from github decisionpatterns/tidyimpute”)

Load the carInsurance data set about the insurance risk rating of cars based on several characteristics of each car1

(a) Check if there are any missing values. (Compruebe si faltan valores)
```{r}
library(dplyr)
library(na.tools)
library(tidyimpute)
library(tidyverse)

# Carga el archivo .Rdata
df <- load("R:/Politécnica.Nacional/2023-A/Data Mining/Deberes.Data/carInsurance.Rdata")

# Obtiene y verifica los objetos cargados en el entorno
#ls()
carIns

# Verifica si hay valores faltantes
if(any_na(carIns)){
  print("Existe valores faltantes en el objeto 'carIns'")
} else{
  print("No esxiste valores faltantes en el objeto 'carIns")
}
```

(b) Cuente el número de casos que tienen, al menos, un valor faltante.
```{r}
# Filtrar los casos con al menos un valor faltante
casosFaltantes <- carIns %>% filter_any_na()

# Numero de casos con numeros faltantes
numCasosFaltantes <- casosFaltantes %>% count()

# Imprime el numero de casos faltantes
print(numCasosFaltantes)
```

(c) Cree un nuevo conjunto de datos eliminando todos los casos que tengan valores faltantes.
```{r}
# Crea un nuevo conjunto de datos eliminando las filas que con valores faltantes
nuevo_df <- drop_rows_any_na(carIns)

print(nuevo_df)
```

(d) Cree un nuevo conjunto de datos ingresando todos los valores faltantes con 0.
Consejo: explore las variantes de la función impute()
```{r}
# Convertir el objeto en un dataframe
df <- as.data.frame(carIns)

# Recorrer las columnas del dataframe
for (col in names(df)) {
  # Reemplazar los valores faltantes por ceros en cada columna
  df[is.na(df[, col]), col] <- 0
}

# Imprimir el dataframe con los valores faltantes reemplazados por 0
print(df)
```

(e) Cree un nuevo conjunto de datos imputando la media en todas las columnas que tengan valores de tipo double.
```{r}
# Convertir el objeto en un dataframe
df <- as.data.frame(carIns)

# Calcula la Media e imputa en todas las columnas de tipo double
dataMedia <- df %>% 
  mutate_if(is.double, ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))
# mutate_if realiza cambios condicionales en las columnas de acuerdo a una condicion especifica
#is.double funcion que devuelve TRUE para las columnas que cumplan la condicion de tipo double

# Imprime el conjunto de datos
print(dataMedia)
```

(f) Cree un nuevo conjunto de datos ingresando la moda en todas las columnas que tienen valores de tipo entero.
```{r}
# Convertir el objeto en un dataframe
df <- as.data.frame(carIns)

# Función para calcular la moda
calculate_mode <- function(x) {
  mod <- as.data.frame(table(x))
  mod <- mod[which.max(mod$Freq), 1]
  return(mod)
}

# Calcula la Moda de las columnas numericas de un dataframe y reemplaza los valores NA por la moda correspondiente a cada columna
dataModa <- df %>%
  mutate(across(where(is.numeric), ~ ifelse(is.na(.), calculate_mode(.), .)))
# across selecciona las columnas que cumplen una determinada condicion, en nuestro caso las columnas numericas


# Imprime el nuevo conjunto de datos
print(dataModa)
```

(g) Cree un nuevo conjunto de datos imputando el valor más frecuente a la columna "nDoors". Sugerencia: utilice la función impute_replace()
```{r}
# Crea una copia del dataframe cargado
dfValFrecuente <- df

# Calcula la moda de la columna "nDoors"
modaNdoors <- calculate_mode(dfValFrecuente$nDoors)

# Reemplaza los valores NA de la columna nDoors con la moda calculada
dfValFrecuente <- dfValFrecuente %>%
  mutate(nDoors = replace_na(nDoors, modaNdoors))

# Imprime el nuevo dataframe
print(dfValFrecuente)
```

h) Combinar las tres últimas imputaciones para obtener un conjunto de datos definitivo.
```{r}
# Convertir el objeto en un dataframe
df <- as.data.frame(carIns)

# Imputar la media en las columnas de tipo double
dataH <- df %>% 
  mutate_if(is.double, ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))

# Función para calcular la moda
calculate_mode <- function(x) {
  mod <- as.data.frame(table(x))
  mod <- mod[which.max(mod$Freq), 1]
  return(mod)
}

# Calcula la Moda de las columnas numericas de un dataframe y reemplaza los valores NA por la moda correspondiente a cada columna
dfH <- df %>%
  mutate(across(where(is.numeric), ~ ifelse(is.na(.), calculate_mode(.), .)))

# Calcula la moda de la columna "nDoors"
modaNdoors <- calculate_mode(dfH$nDoors)

# Reemplaza los valores NA de la columna nDoors con la moda calculada
dfH <- dfH %>%
  mutate(nDoors = replace_na(nDoors, modaNdoors))

# Imprimir el nuevo dataframe imputado
print(dfH)
```
¿Hay casos duplicados?
Consejo: utilice las funciones distinct() y count()
```{r}
# Identifica los casos duplicados en el dataframe
duplicados <- dfH[duplicated(dfH),]
# En caso de haber duplicados se las puede eliminar con la funcion distintct()

# Cuenta los casos duplicados para todas las columnas
contDuplicados <- count(duplicados, across(everything()))
# Cuenta la frecuencia de aparicion de cada combinacion de valores en todas las columnas

# Imprime los cados duplicados y su contador
print(duplicados)
print(contDuplicados)
```
## 2. Data Pre-Processing

2. Cargue el paquete dlookr. Utilice el mismo conjunto de datos de seguro de automóvil anterior y aplique lo siguiente transformaciones al atributo price. Sé crítico con los resultados obtenidos.

(a) Aplicar normalización basada en rangos y normalización de Z-score.
```{r}
library(dplyr)

# Convertir el objeto en un dataframe
dfNorm <- as.data.frame(carIns)

dfNorm <- dfNorm %>%
  mutate(
          # Aplica la normalización basada en rangos
          precioNormRango = (price - min(price, na.rm = TRUE)) / (max(price, na.rm = TRUE) - min(price, na.rm = TRUE)), # Escala los valores de la columna de precio al rango [0,1]
          # Aplica la normalización Z-score
          precioNormZscore = (price - mean(price, na.rm = TRUE)) / sd(price, na.rm = TRUE)
)

# Imprime el nuevo dataframe
print(dfNorm)

```

(b) Discretizar en 4 rangos de igual frecuencia y en 4 rangos de igual ancho. Sugerencia: utilice la función binning().
```{r}
library(dlookr)

# COnvertir el objeto en un dataframe
dfDisc <- as.data.frame(carIns)

# Discretizar en 4 rangos de igual frecuencia
dfDisc$priceFrec <- cut(dfDisc$price, breaks = 4, labels = FALSE)

# Discretizar en 4 rangos de igual ancho
dfDisc$priceAnc <- cut(dfDisc$price, breaks = 4, labels = FALSE, include.lowest = TRUE)

# Imprime el nuevo dataframe
print(dfDisc)

```
3. Con la semilla 111019, obtenga las siguientes muestras en el conjunto de datos de seguro de automóvil.
Sugerencia: utilice la función sample_frac().

(a) Una muestra aleatoria del 60% de los casos, con reemplazo.
```{r}
# Establece el valor de semilla para reproducibilidad
set.seed(111019)  

# Convierte el objeto en dataframe
dfAuto <- as.data.frame(carIns)

# Obtiene una muestra aleatoria del %60 de los casos con reemplazo
dfAuto <- sample_frac(dfAuto, 0.6, replace = TRUE)

# Imprime el nuevo dataframe
print(dfAuto)
```

(b) Una muestra estratificada del 60% de los casos de automóviles, según el atributo de tipo de combustible (fuelType).
```{r}
# Establece el valor de semilla para reproducibilidad
set.seed(111019) 

# Convierte el objeto en un dataframe
dfComb <- as.data.frame(carIns)

# Crea una muestra estratificada del %60 basada en el atributo fuelType

dfComb <- dfComb %>%
  group_by(fuelType) %>%
  group_split() %>%   # Divide en grupos segun los valores unicos de fuelType
  lapply(function(group) sample_frac(group, 0.6, replace = FALSE)) %>% 
  bind_rows()

# Imprime el dataframe resultante
print(dfComb)
    
```

(c) Utilice la función table() para inspeccionar la distribución de valores en cada una de las dos muestras anteriores.
```{r}
# Establece la semilla para reproducibilidad
set.seed(111019)

# Convierte el objeto en un dataframe
dfTable <- as.data.frame(carIns)

# Muestra aleatoria del %60 de los casos con reemplazo
mAleatoria <- sample_frac(dfTable, 0.6, replace = TRUE)

# # Muestra estratificada del 60% de los casos de automóviles según fuelType
set.seed(111019)
mEstratificada <- dfTable %>%
  group_by(fuelType) %>%
  sample_frac(0.6, replace = FALSE) %>%
  ungroup()

# Inspecciona la distribucion de valores en cada muestra
distAleatoria <- table(mAleatoria$fuelType)
disEstratificada <- table(mEstratificada$fuelType)

# Imprime la distribucion de valores en cada muestra
print(distAleatoria)
print(disEstratificada)
```

4. Cargue el paquete corrplot y seleccione los atributos numéricos del conjunto de datos de seguro de automóvil.
```{r}
library(corrplot)

# Convierte el objeto en un dataframe
dfCar <- as.data.frame(carIns)

# Selecciona los atributos numericos
dfCar <- select_if(dfCar, is.numeric)
```

```{r}
# Calcula el coeficiente de Pearson entre cada par de variables
dfCorrelacionMatriz <- cor(dfCar)

# Imprime la matriz de correlacion
print(dfCorrelacionMatriz)
```
(b) Aplicar la función cor.test() al resultado anterior para calcular los valores p y los intervalos de confianza del coeficiente de correlación para cada par de variables.

```{r}
# Aplicar cor.test() a cada par de variables en la matriz de correlación
cor_test_results <- apply(dfCorrelacionMatriz, 2, function(x) {
  apply(dfCorrelacionMatriz, 2, function(y) {
    # Verifica si hay al menos 3 observaciones válidas en los pares de variables antes de realizar la prueba de correlación, si no hay se establece como NA
    if (sum(!is.na(x) & !is.na(y)) >= 3) {
      cor.test(x, y)
    } else {
      list(p.value = NA, conf.int = NA)
    }
  })
})

# Imprimir los resultados
# Recorre la matriz
for (i in 1:ncol(dfCorrelacionMatriz)) {
  for (j in 1:ncol(dfCorrelacionMatriz)) {
    result <- cor_test_results[[i]][[j]]
    p_value <- result$p.value
    conf_interval <- result$conf.int
    
    # Imprime 
    print(paste("Variables:", names(dfCorrelacionMatriz)[i], "-", names(dfCorrelacionMatriz)[j]))
    if (!is.na(p_value)) {
      print(paste("p-value:", p_value))
      print("Confidence Interval:")
      print(conf_interval)
    } else {
      print("No hay suficientes observaciones para calcular la correlación.")
    }
    print("-----------")
  }
}
```

(c) Trazar toda la información de correlación usando la función corrplot. Explora algunos de sus parámetros
```{r}
library(corrplot)

# Trazar la matriz de correlacion
corrplot(dfCorrelacionMatriz, method = "circle", type = "upper", tl.cex = 0.7)
# method = "circle" indica que se desea representar los coeficientes de correlación utilizando un gráfico de círculo.
# type = "upper" muestra solo la mitad superior de la matriz de correlación, ya que la mitad inferior es simétrica.
# tl.cex = 0.7: Controla el tamaño de las etiquetas que se muestran en la matriz de correlación
```

5. Cargue el conjunto de datos USJudgeRatings, del paquete de conjuntos de datos, que contiene las calificaciones de los abogados de los jueces estatales en el Tribunal Superior de EE.UU. con respecto a un conjunto de atributos.

```{r}
# Cargar el archivo csv USJudgeRatings
ruta <- file.path("R:/Politécnica.Nacional/2023-A/Data Mining/Deberes.Data/USJudgeRatings.csv")
dfJudge <- read.csv(ruta)

print(dfJudge)
#
```

(a) Aplique la función prcomp() para obtener los componentes principales. Inspeccione cómo se obtiene cada variable mediante la combinación lineal de cada componente.
```{r}
# Excluir la 1ra columna del conjunto de datos
dfNumeros <- dfJudge[, -1]

# Aplicar la funcion prcomp()
dfComponentes <- prcomp(dfNumeros)

# Obtiene los componentes principales
componentes <- dfComponentes$x

# Inspecciona la combinacion lineal de cada variable en cada componente
for (i in 1:length(dfComponentes$rotation)) {
  # Obtiene el numero de columnas de dfComponentes$rotationy se asegura de que i sea menor o igual a ese numero
  if (i <= ncol(dfComponentes$rotation)) {
    variable <- names(dfNumeros)[i]
    combLineal <- dfComponentes$rotation[, i]

    print(paste("Variable:", variable))
    print("Combinación lineal en cada componente:")
    print(combLineal)
    print("----------------")
  }
}

```

(b) Cargue el paquete ggbiplot y trace los dos primeros componentes con la función ggbiplot (). Puede etiquetar cada punto con el nombre del abogado configurando el parámetro etiquetas.
```{r}
# Cambiar nombre a columna
dfJudge %>% rename(Nombre=X)

```


```{r}
library(ggplot2)

# Verificar si hay valores faltantes en los componentes
if (any(is.na(componentes))) {
  stop("Existen valores faltantes en los componentes principales.")
}

# Verificar si los componentes y los nombres de los abogados tienen la misma longitud
if (length(componentes) != length(dfJudge$Nombre)) {
  stop("Los componentes y los nombres de los abogados tienen diferente longitud.")
}

# Crear un dataframe con los componentes y los nombres de los abogados
dfComponentes <- data.frame(componente1 = componentes[, 1], componente2 = componentes[, 2], abogado = dfJudge$Nombre)

# Plot de los componentes principales con etiquetas de Nombre de abogado
ggplot(dfComponentes, aes(x = componente1, y = componente = 2, label = Nombre)) +
  geom_text() +
  labs( x = 'Componente 1', y = 'Componente 2') + 
  theme_minimal()


```
No se puede imprimir las etiquetas con nombres de los abogados, por lo que se procede a imprimir sin las etiquetas de nombre de abogados

```{r}
library(ggplot2)

# Crear un dataframe con los componentes principales y los nombres de los abogados
df_plot <- data.frame(Componente1 = componentes[, 1], Componente2 = componentes[, 2], Abogado = rownames(dfNumeros))

# Trama de dispersión de los componentes principales
ggplot(df_plot, aes(x = Componente1, y = Componente2, label = Abogado)) +
  geom_point() +
  geom_text(hjust = 0, vjust = 0)
```
